/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree.
 */

//! digests parser generated by buck:helpers.bzl

use std::convert::Infallible;
use std::path::PathBuf;

use nom::char;
use nom::count;
use nom::is_not;
use nom::map_res;
use nom::named;
use nom::one_of;
use nom::pair;
use nom::preceded;
use nom::separated_list1;
use nom::tag;

static DIGESTS: &'static [u8] = include_bytes!("combined_digests");

#[derive(Clone, Debug, PartialEq, Eq)]
struct ImageDigest {
    name: String,
    path: PathBuf,
    digest: String,
}

#[derive(Clone, Debug, PartialEq, Eq)]
struct NamedDigest {
    name: String,
    digest: String,
}

impl From<ImageDigest> for NamedDigest {
    fn from(digest: ImageDigest) -> Self {
        Self {
            name: digest.name,
            digest: digest.digest,
        }
    }
}

impl From<&ImageDigest> for NamedDigest {
    fn from(digest: &ImageDigest) -> Self {
        Self {
            name: digest.name.clone(),
            digest: digest.digest.clone(),
        }
    }
}

named!(
    sha256_digest_p_1<(Vec<char>, &[u8])>,
    pair!(
        count!(one_of!("0123456789abcdefABCDEF"), 64),
        preceded!(tag!(" *"), is_not!("\n"))
    )
);

named!(
    sha256_digest_p<ImageDigest>,
    map_res!(sha256_digest_p_1, |(digest, path)| {
        let path = String::from_utf8_lossy(path).to_string();
        let path = PathBuf::from(path);
        let name = path.file_name().unwrap().to_string_lossy().to_string();
        Ok::<_, Infallible>(ImageDigest {
            name,
            path,
            digest: String::from_iter(digest),
        })
    })
);

named!(
    sha256_digests_p<Vec<ImageDigest>>,
    separated_list1!(char!('\n'), sha256_digest_p)
);

named!(
    sha256_digests_list_p<Vec<Vec<ImageDigest>>>,
    separated_list1!(tag!("\n>>>\n"), sha256_digests_p)
);

fn parse_image_digests(digest_bin: &[u8]) -> Vec<Vec<ImageDigest>> {
    let digests = sha256_digests_list_p(digest_bin);

    digests.unwrap().1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_digests_one() {
        assert_eq!(
            sha256_digest_p(
                &b"33048fc67b043a586023c82d9cf05432e212ae935a821c5da5b0a24228732151 */bin/ls\n"[..]
            ),
            Ok((
                &b"\n"[..],
                ImageDigest {
                    name: String::from("ls"),
                    path: PathBuf::from("/bin/ls"),
                    digest: String::from(
                        "33048fc67b043a586023c82d9cf05432e212ae935a821c5da5b0a24228732151"
                    ),
                }
            ))
        );
    }

    #[test]
    // Verify digests generated by helpers:gen_image_rpmbuild_digests, to
    // make sure two hermetic rpmbuild are indeed bitwise reproducible
    fn rpmbuild_verify_digests() {
        let digests = parse_image_digests(DIGESTS);
        assert!(digests.len() >= 2);

        let mut named_digests = digests.iter().map(|s| {
            s.iter()
                .map(|d| NamedDigest::from(d))
                .collect::<Vec<NamedDigest>>()
        });

        let first = named_digests.next();
        assert!(first.is_some());
        let first = first.unwrap();
        while let Some(next) = named_digests.next() {
            assert_eq!(first, next);
        }
    }
}
